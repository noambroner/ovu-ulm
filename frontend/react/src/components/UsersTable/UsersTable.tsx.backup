import { useState, useEffect, useMemo } from 'react';
import type { Language, Theme } from '../types';
import './UsersTable.css';
import { EditUserModal } from '../EditUserModal/EditUserModal';

interface User {
  id: number;
  username: string;
  email: string;
  role: string;
  created_at: string;
}

interface UsersTableProps {
  language: Language;
  theme: Theme;
  apiEndpoint: string;
  token: string;
}

type SortField = keyof User | null;
type SortDirection = 'asc' | 'desc';

const translations = {
  he: {
    title: 'ניהול משתמשים',
    actions: 'פעולות',
    edit: 'עריכה',
    loading: 'טוען...',
    error: 'שגיאה בטעינת המשתמשים',
    noUsers: 'אין משתמשים',
    search: 'חיפוש...',
    totalUsers: 'סה"כ משתמשים',
    columns: {
      id: 'מזהה',
      username: 'שם משתמש',
      email: 'אימייל',
      role: 'תפקיד',
      created_at: 'תאריך יצירה',
    },
    roles: {
      user: 'משתמש',
      admin: 'מנהל',
      super_admin: 'מנהל על'
    },
    never: 'אף פעם'
  },
  en: {
    title: 'User Management',
    actions: 'Actions',
    edit: 'Edit',
    loading: 'Loading...',
    error: 'Error loading users',
    noUsers: 'No users found',
    search: 'Search...',
    totalUsers: 'Total Users',
    columns: {
      id: 'ID',
      username: 'Username',
      email: 'Email',
      role: 'Role',
      created_at: 'Created',
    },
    roles: {
      user: 'User',
      admin: 'Admin',
      super_admin: 'Super Admin'
    },
    never: 'Never'
  }
};

export const UsersTable = ({ language, apiEndpoint, token }: UsersTableProps) => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [sortField, setSortField] = useState<SortField>('created_at');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');
  const [columnFilters, setColumnFilters] = useState<Record<string, string>>({});
  const [editingUser, setEditingUser] = useState<User | null>(null);
  const [openMenuId, setOpenMenuId] = useState<number | null>(null);
  const [menuPosition, setMenuPosition] = useState<{ x: number; y: number } | null>(null);
  const [closingMenuId, setClosingMenuId] = useState<number | null>(null);
  const [highlightingUserId, setHighlightingUserId] = useState<number | null>(null);
  const [updatedFields, setUpdatedFields] = useState<Set<string>>(new Set());

  useEffect(() => {  }, [openMenuId, closingMenuId, menuPosition]);



  const t = translations[language];

  useEffect(() => {
    fetchUsers();
  }, [apiEndpoint, token]);

  const fetchUsers = async () => {
    try {
      setLoading(true);
      const response = await fetch(`${apiEndpoint}/api/v1/users`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (!response.ok) {
        throw new Error('Failed to fetch users');
      }

      const data = await response.json();
      setUsers(data.users);
      setError(null);
    } catch (err) {
      setError(t.error);
      console.error('Error fetching users:', err);
    } finally {
      setLoading(false);
    }
  };

  const handleSort = (field: keyof User) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
  };

  const handleColumnFilter = (column: string, value: string) => {
    setColumnFilters(prev => ({
      ...prev,
      [column]: value
    }));
  };

  const filteredAndSortedUsers = useMemo(() => {
    let result = [...users];

    // Global search
    if (searchTerm) {
      result = result.filter(user =>
        Object.values(user).some(val =>
          String(val).toLowerCase().includes(searchTerm.toLowerCase())
        )
      );
    }

    // Column filters
    Object.entries(columnFilters).forEach(([column, filterValue]) => {
      if (filterValue) {
        result = result.filter(user =>
          String(user[column as keyof User]).toLowerCase().includes(filterValue.toLowerCase())
        );
      }
    });

    // Sort
    if (sortField) {
      result.sort((a, b) => {
        const aVal = a[sortField];
        const bVal = b[sortField];

        if (aVal === null) return 1;
        if (bVal === null) return -1;

        let comparison = 0;
        if (typeof aVal === 'string' && typeof bVal === 'string') {
          comparison = aVal.localeCompare(bVal);
        } else if (typeof aVal === 'number' && typeof bVal === 'number') {
          comparison = aVal - bVal;
        }

        return sortDirection === 'asc' ? comparison : -comparison;
      });
    }

    return result;
  }, [users, searchTerm, columnFilters, sortField, sortDirection]);

  const formatDate = (dateString: string | null) => {
    if (!dateString) return t.never;
    const date = new Date(dateString);
    return date.toLocaleDateString(language === 'he' ? 'he-IL' : 'en-US', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  const getRoleBadgeClass = (role: string) => {
    switch (role) {
      case 'super_admin': return 'role-badge role-super-admin';
      case 'admin': return 'role-badge role-admin';
      default: return 'role-badge role-user';
    }
  };

  const translateRole = (role: string) => {
    return t.roles[role as keyof typeof t.roles] || role;
  };


  const handleEdit = (user: User) => {
    setEditingUser(user);
    setOpenMenuId(null);
  };

  const handleSaveUser = async (id: number, updates: { username: string; email: string; role: string }) => {
    try {
      // Find original user to compare changes
      const originalUser = users.find(u => u.id === id);
      const changedFields = new Set<string>();
      
      if (originalUser) {
        if (originalUser.username !== updates.username) changedFields.add('username');
        if (originalUser.email !== updates.email) changedFields.add('email');
        if (originalUser.role !== updates.role) changedFields.add('role');
      }

      const response = await fetch(`${apiEndpoint}/api/v1/users/${id}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(updates)
      });

      if (!response.ok) {
        throw new Error('Failed to update user');
      }

      // Refresh users list
      await fetchUsers();
      
      // Trigger highlight animation
      setHighlightingUserId(id);
      setUpdatedFields(changedFields);
      
      // Remove highlight after animation
      setTimeout(() => {
        setHighlightingUserId(null);
        setUpdatedFields(new Set());
      }, 1500);
    } catch (err) {
      console.error('Error updating user:', err);
      throw err;
    }
  };

  const toggleMenu = (userId: number, event: React.MouseEvent<HTMLButtonElement>) => {    if (openMenuId === userId) {      closeMenu();
    } else {
      const button = event.currentTarget;
      const rect = button.getBoundingClientRect();      const position = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };      setMenuPosition(position);      setOpenMenuId(userId);
    }
  };

  const closeMenu = () => {
    if (openMenuId) {
      setClosingMenuId(openMenuId);
      setTimeout(() => {
        setOpenMenuId(null);
        setClosingMenuId(null);
        setMenuPosition(null);
      }, 300); // Match animation duration
    }
  };

  const handleMenuAction = (action: () => void) => {
    action();
    closeMenu();
  };

  if (loading) {
    return <div className="users-loading">{t.loading}</div>;
  }

  if (error) {
    return <div className="users-error">{error}</div>;
  }

  return (
    <>
    <div className="users-table-container">
      <div className="users-header">
        <h2 className="users-title">{t.title}</h2>
        <div className="users-stats">
          <span className="total-count">{t.totalUsers}: {users.length}</span>
        </div>
      </div>

      <div className="users-controls">
        <input
          type="text"
          className="global-search"
          placeholder={t.search}
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
        />
      </div>

      <div className="table-wrapper">
        <table className="users-table">
          <thead>
            <tr>
              <th className="actions-column">{t.actions}</th>
              <th onClick={() => handleSort('id')}>
                <div className="th-content">
                  {t.columns.id}
                  {sortField === 'id' && (
                    <span className="sort-indicator">{sortDirection === 'asc' ? '↑' : '↓'}</span>
                  )}
                </div>
                <input
                  type="text"
                  className="column-filter"
                  placeholder="..."
                  value={columnFilters.id || ''}
                  onChange={(e) => handleColumnFilter('id', e.target.value)}
                  onClick={(e) => e.stopPropagation()}
                />
              </th>
              <th onClick={() => handleSort('username')}>
                <div className="th-content">
                  {t.columns.username}
                  {sortField === 'username' && (
                    <span className="sort-indicator">{sortDirection === 'asc' ? '↑' : '↓'}</span>
                  )}
                </div>
                <input
                  type="text"
                  className="column-filter"
                  placeholder="..."
                  value={columnFilters.username || ''}
                  onChange={(e) => handleColumnFilter('username', e.target.value)}
                  onClick={(e) => e.stopPropagation()}
                />
              </th>
              <th onClick={() => handleSort('email')}>
                <div className="th-content">
                  {t.columns.email}
                  {sortField === 'email' && (
                    <span className="sort-indicator">{sortDirection === 'asc' ? '↑' : '↓'}</span>
                  )}
                </div>
                <input
                  type="text"
                  className="column-filter"
                  placeholder="..."
                  value={columnFilters.email || ''}
                  onChange={(e) => handleColumnFilter('email', e.target.value)}
                  onClick={(e) => e.stopPropagation()}
                />
              </th>
              <th onClick={() => handleSort('role')}>
                <div className="th-content">
                  {t.columns.role}
                  {sortField === 'role' && (
                    <span className="sort-indicator">{sortDirection === 'asc' ? '↑' : '↓'}</span>
                  )}
                </div>
                <input
                  type="text"
                  className="column-filter"
                  placeholder="..."
                  value={columnFilters.role || ''}
                  onChange={(e) => handleColumnFilter('role', e.target.value)}
                  onClick={(e) => e.stopPropagation()}
                />
              </th>
              <th onClick={() => handleSort('created_at')}>
                <div className="th-content">
                  {t.columns.created_at}
                  {sortField === 'created_at' && (
                    <span className="sort-indicator">{sortDirection === 'asc' ? '↑' : '↓'}</span>
                  )}
                </div>
                <input
                  type="text"
                  className="column-filter"
                  placeholder="..."
                  value={columnFilters.created_at || ''}
                  onChange={(e) => handleColumnFilter('created_at', e.target.value)}
                  onClick={(e) => e.stopPropagation()}
                />
              </th>
            </tr>
          </thead>
          <tbody>
            {filteredAndSortedUsers.length === 0 ? (
              <tr>
                <td colSpan={6} className="no-results">{t.noUsers}</td>
              </tr>
            ) : (
              filteredAndSortedUsers.map(user => (
                <tr 
                  key={user.id} 
                  className={`${
                    (openMenuId === user.id || closingMenuId === user.id || editingUser?.id === user.id) 
                      ? "row-selected" 
                      : ""
                  } ${
                    highlightingUserId === user.id 
                      ? "row-highlighting" 
                      : ""
                  }`.trim()}
                >
                  <td className="actions-cell">
                    <div className="actions-menu">
<button 
                        className={`menu-btn ${openMenuId === user.id ? "active" : ""}`}
                        onClick={(e) => toggleMenu(user.id, e)}
                        title={t.actions}
                      >
                        ⋮
                      </button>
                    </div>
                  </td>
                  <td>{user.id}</td>
                  <td className={`username-cell ${highlightingUserId === user.id && updatedFields.has("username") ? "field-updated" : ""}`.trim()}><span className="field-content">{user.username}</span></td>
                  <td className={`email-cell ${highlightingUserId === user.id && updatedFields.has("email") ? "field-updated" : ""}`.trim()}><span className="field-content">{user.email}</span></td>
                  <td className={`${highlightingUserId === user.id && updatedFields.has("role") ? "field-updated" : ""}`.trim()}>
                    <span className={`${getRoleBadgeClass(user.role)} field-content`}>
                      {translateRole(user.role)}
                    </span>
                  </td>
                  <td className="date-cell">{formatDate(user.created_at)}</td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>

    {/* Animated Center Menu */}
      {(openMenuId || closingMenuId) && (
        <>
          <div 
            className="menu-backdrop" 
            onClick={closeMenu}
            style={{ 
              animation: closingMenuId ? 'backdropFadeOut 0.25s ease-out forwards' : 'backdropFadeIn 0.25s ease-out forwards'
            }}
          />
          <div 
            className={`center-dropdown-menu ${closingMenuId ? "closing" : ""}`}
            style={{
              "--start-x": menuPosition ? `${menuPosition.x}px` : "50%",
              "--start-y": menuPosition ? `${menuPosition.y}px` : "50%",
            } as React.CSSProperties}
          >
            <button 
              className="menu-item"
              onClick={() => handleMenuAction(() => handleEdit(
                filteredAndSortedUsers.find(u => u.id === (openMenuId || closingMenuId))!
              ))}
            >
              ✏️ {t.edit}
            </button>
          </div>
        </>
      )}

    {editingUser && (
        <EditUserModal
          user={editingUser}
          language={language}
          onClose={() => setEditingUser(null)}
          onSave={handleSaveUser}
        />
      )}
  </>
  );
};
